// @File (label="source directory",style="directory") dir1
// @File (label="destination directory",style="directory") dir2
// @String (label="open only files of type",choices={".lif"}) infiletype
// @String (label="open only files of type",choices={".ids", ".ome.tif"}) outfiletype
// @String (label="Stitchmode?",choices={"Grid", "inLine"}) opt

batch = "yes";
infiletype = ".lif";

//-----------------------------------------------------------------------
//  The script allows to stitch multiple tile-scanning .lif files in batch.
//  It allows the user to choose a source directory containing the .lif files and a destination directory, where
//  the final, stitched images will be saved. It further allows the user to specify the output file format and
//  select between two stitching options:
//
//  Options:
//
//  - Grid: will use the Grid/Collection stitching based on the metadata of the file. The plugin has been written by
//  Preibisch et al., Bioinformatics (2009).
//
//  - inLine: will use Pairwise stitching(plugin written by Preibisch et al., Bioinformatics (2009)) and stitch the
//  single tiles with each other one by one.
//  !Note: This function has been written only for tiles acquired in line!
//
//  The stitched image is further saved in the specified destination folder in the specified file format. The script
//  further continues to stitch all .lif files in the specified Input folder.
//
//  This script was written for Daniel Heutschi by Etienne Schmelzer
//------------------------------------------------------------------------


function getTimestamp() {
// generates a Timestamp, no arguments needed
	MonthNames = newArray("Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec");
	DayNames = newArray("Sun", "Mon","Tue","Wed","Thu","Fri","Sat");
	getDateAndTime(year, month, dayOfWeek, dayOfMonth, hour, minute, second, msec);
	TimeString ="Date: "+DayNames[dayOfWeek]+" ";
	if (dayOfMonth<10) {TimeString = TimeString+"0";}
	TimeString = TimeString+dayOfMonth+"-"+MonthNames[month]+"-"+year+" Time: ";
	if (hour<10) {TimeString = TimeString+"0";}
	TimeString = TimeString+hour+":";
	if (minute<10) {TimeString = TimeString+"0";}
	TimeString = TimeString+minute+":";
	if (second<10) {TimeString = TimeString+"0";}
	TimeString = TimeString+second;
	//print(TimeString);
	return TimeString;
}


function tiles_rename() {
	// as the tile scans generated by leica have all the same names
	// this function renames the tile scans to facilitate further handling
	all = newArray(nImages);
	i=1;
	for (k=0; k<nImages; k++) {
		selectImage(k+1);
		imageTitle = getTitle();
		// regular expression testing if the selected image is the merged image produced by Leica
		if (matches(imageTitle, ".*Merging.*")) {
			print("Yes");
			rename("Merge");
		} else {
			new="tile_" + i;
			i=i+1;
			rename(new);
		}
	};
}

function stitchInLine(originaln, filename) {
    // will stitch tile1 with tile2 then merge the fused image with tile3 ...
    // the final image will be renamed according to the provided filename.
	selectWindow("tile_1");
	rename("fused_1");
	for (k=2; k<=originaln-1; k++) {
		print(k);
		t=k-1;
		run("Pairwise stitching", "first_image=[fused_"+ t +"] second_image=[tile_"+ k +"] fusion_method=[Linear Blending] fused_image=fused_"+k+" check_peaks=5 compute_overlap x=921.0000 y=0.0000 z=0.0000 registration_channel_image_1=[Average all channels] registration_channel_image_2=[Average all channels]");
		close("fused_"+t);
	};
	selectWindow("fused_"+ originaln-1);
	rename(filename);
}

function inLineStitcher(filepath, filename) {
	// opens the Image file and executes the function tiles_rename(), renaming the tiles and
	// further executes the stitchInLine function.
	run("Bio-Formats Importer", "open="+ filepath +" autoscale color_mode=Default open_all_series rois_import=[ROI manager] view=Hyperstack stack_order=XYCZT");
	originaln=nImages;
	tiles_rename();
	stitchInLine(originaln, filename);
}

function GridStitcher(filepath, filename) {
	// calls the Plugin Grid/Collection stitching"
	// Settings: uses the metadata of the file to align and stitch the images with each other
	// filepath: filepath to the multiimage container file e.g. .lif
	// filename: the name of the resulting file
	run("Grid/Collection stitching", "type=[Positions from file] order=[Defined by image metadata] multi_series_file=" + filepath + " fusion_method=[Linear Blending] regression_threshold=0.30 max/avg_displacement_threshold=2.50 absolute_displacement_threshold=3.50 compute_overlap increase_overlap=0 ignore_z_stage computation_parameters=[Save computation time (but use more RAM)] image_output=[Fuse and display]");
	rename(filename);
}

function LukeFileWalker(dir1, dir2, outfiletype, opt){
	// walks through the files contained in dir1, executes the specified functions and saves
	// the resulting image file in the outputfolder dir2 as the specified outfiletype. opt allows the user
	// to choose between the inLineStitcher function and the Grid/Collection function.
	list = getFileList(dir1);
	for (i=0; i<list.length; i++) {
		if(endsWith(list[i], infiletype)){
			print("Processing:     (" +i +"/"+ list.length + ") \n" +  list[i]);
			title = split(list[i],".");
			filename = title[0];
			filepath = dir1+ File.separator + list[i];
			//print(filepath + "__" + filename);


			//insert function
			//-----------------------------------------------
			if (opt=="inLine") {
				inLineStitcher(filepath, filename);
			} else {
				GridStitcher(filepath, filename);
			}


			//GridStitcher(filepath, filename);
			outfilepath = dir2 + File.separator + filename + outfiletype;
			//print(outfilepath);
			print("Saving:" + outfilepath);
			run("Bio-Formats Exporter", "save=["+ outfilepath +"]");
			run("Bio-Formats Exporter", "save=["+ outfilepath +"]");
			close("Exception");
			run("Close All");
		}
	};
}

//-----------------------------------


if (batch == "yes") {
				setBatchMode(true);
}

// prints the timestamp into the log.txt
print("The script started at: " + getTimestamp());

LukeFileWalker(dir1, dir2, outfiletype, opt);

print("All data has been processed");
print("The script finished at: " + getTimestamp());
